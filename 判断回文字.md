以下是关于回文字符串的笔记：
这是我目前遇到的以后遇到再加

# 判断回文字符串 (Palindrome)

回文字符串是从前向后和从后向前读都是一样的字符串。

### 示例

1. "aba"
2. "abba"
3. "racecar"
4. "level"

## 方法一：双指针法
### 写法1：

通过比较字符串的首尾字符来判断其是否为回文。

```cpp
bool is_palindrome(string s) {
    int n = s.size();
    for (int i = 0; i < n / 2; i++) //在这里i<n,i<n/2都是可以的，后者遍历一半，更快。
        if (s[i] != s[n - i - 1]) return false;
    return true;
}
```

### 写法2：

使用两个指针，一个从字符串的开始，另一个从字符串的结尾开始，向中间移动并比较字符。

```cpp
bool isPalindrome(string s) {
    int left = 0, right = s.size() - 1;
    while (left < right) {
        if (s[left] != s[right]) return false;
        left++;
        right--;
    }
    return true;
}
```
## 奇偶性对双指针法没有影响
### 奇数长度 "abcba"
![回文字1](https://github.com/WenbinBAI/AtCoder-Beginner-Contest-Nootbook/assets/77138767/f63e19c3-9703-4fbe-bbef-6e38aff1c2f7)
```markdown
# 分析：

使用一个长方形代表整个字符串。
将长方形均匀地分为5部分（因为字符串有5个字符）。
在第1和第5部分上分别写上字母'a'。
在第2和第4部分上分别写上字母'b'。
在中间的部分写上字母'c'。
使用箭头指示第1部分与第5部分的比较，以及第2部分与第4部分的比较。
注意中间的部分是没有箭头的，因为我们不需要比较这部分。
```
### 偶数长度："abccba"
![回文字2](https://github.com/WenbinBAI/AtCoder-Beginner-Contest-Nootbook/assets/77138767/be05bfd5-444e-4c67-94ca-e316bb2cdd99)
```markdown

与上述类似，但这次你的长方形应该被均匀地分为6部分。
在第1和第6部分上分别写上字母'a'。
在第2和第5部分上分别写上字母'b'。
在第3和第4部分上分别写上字母'c'。
使用箭头指示每一对字符的比较。

# 结论
使用 i < n/2 作为循环条件可以确保我们的方法在处理奇数和偶数长度的字符串时都是有效的。对于奇数长度的字符串，我们不需要考虑中心字符，而对于偶数长度的字符串，我们确保了每个前半部分字符都与其对应的后半部分字符进行了比较。
```






## 方法：中心展开
```cpp
int expandAroundCenter(const std::string& s, int left, int right) {
    while (left >= 0 && right < s.size() && s[left] == s[right]) {
        --left;
        ++right;
    }
    cout << "current s: " << s << endl;
    return right - left - 1;  // Subtract 1 to adjust the indices to get length.
}
```

```markdown
**中心扩展法 (Center Expansion Method)**

中心扩展法是一种用于寻找字符串中所有回文子串的方法。这种方法的核心思想是：考虑每一个可能的中心点，并从该点开始向外扩展，以构建并检测回文。

### 为什么需要中心扩展法？

回文可以分为两类：奇数长度和偶数长度。奇数长度的回文有一个中心，而偶数长度的回文有两个中心。例如：
- 奇数长度：`level`，其中 'v' 是中心。
- 偶数长度：`deed`，其中两个 'e' 是中心。

对于每个字符，我们都考虑它作为奇数长度回文的中心，以及它与下一个字符共同作为偶数长度回文的中心。

### 如何实现？

1. 遍历字符串中的每个字符。
2. 对于当前字符，首先尝试将其作为奇数长度回文的中心，并向左右扩展，直到找到最大的回文。
3. 接下来，尝试将当前字符与其右侧的字符作为偶数长度回文的中心，并向左右扩展，直到找到最大的回文。
4. 记录并更新最长回文子串。

### 优点：

- **简单直观**：这种方法非常直接，只需考虑每个可能的中心点，并尝试构建回文。
- **高效**：虽然看起来存在三层循环（遍历每个字符、尝试两种中心、向外扩展），但实际的时间复杂度是O(n^2)，其中n是字符串的长度。

### 使用场景：

中心扩展法在寻找字符串中的**最长回文子串**问题中尤其有用，因为它可以确保考虑到所有可能的回文，并从中选择最长的一个。

### 示例：

考虑字符串 "babad"，其中 "bab" 和 "aba" 都是回文。使用中心扩展法，我们可以从每个字符开始，找到以其为中心的所有回文，并从中选择最长的一个。

总的来说，中心扩展法是一种强大且直观的方法，用于寻找字符串中的回文子串。

```

## 注意点
- 双指针方法可以处理字符串长度为奇数或偶数的情况。
- 在处理更复杂的回文判断时（如包含非字母字符、大小写不敏感），可能需要在上述代码中添加额外的逻辑。
