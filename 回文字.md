以下是关于回文字符串的笔记：

```markdown
# 回文字符串 (Palindrome)

回文字符串是从前向后和从后向前读都是一样的字符串。

## 示例

1. "aba"
2. "abba"
3. "racecar"
4. "level"

## 判断字符串是否为回文

### 方法1：基本方法

通过比较字符串的首尾字符来判断其是否为回文。

```cpp
bool is_palindrome(string s) {
    int n = s.size();
    for (int i = 0; i < n / 2; i++) //在这里i<n,i<n/2都是可以的，后者遍历一半，更快。
        if (s[i] != s[n - i - 1]) return false;
    return true;
}

```
```markdown
# 分析：

## 奇数长度
考虑字符串 "aba"，其长度为3。在此方法中，遍历是这样的：

## 元素：0，1，2   n/2 = 1;

当 i = 0 时，s[i] 是 'a'，而 s[n - i - 1] 也是 'a'。这两个字符匹配。0，1，2
实际上，由于我们的循环条件是 i < n/2，循环在 i = 1 时结束，因此我们只比较了字符串的前半部分。
对于奇数长度的字符串，中心字符不需要进行比较，因为它不影响字符串是否为回文。

## 偶数长度
考虑字符串 "abba"，其长度为4。遍历是这样的：0，1，2，3。 循环：0，1

当 i = 0 时，s[i] 是 'a'，而 s[n - i - 1] 是 'a'。这两个字符匹配。
当 i = 1 时，s[i] 是 'b'，而 s[n - i - 1] 是 'b'。这两个字符匹配。
由于循环条件是 i < n/2，循环在 i = 2 时停止。这确保了我们比较了字符串的前半部分字符与其对应的后半部分字符。

# 结论
使用 i < n/2 作为循环条件可以确保我们的方法在处理奇数和偶数长度的字符串时都是有效的。对于奇数长度的字符串，我们不需要考虑中心字符，而对于偶数长度的字符串，我们确保了每个前半部分字符都与其对应的后半部分字符进行了比较。
```



### 方法2：双指针方法

使用两个指针，一个从字符串的开始，另一个从字符串的结尾开始，向中间移动并比较字符。

```cpp
bool isPalindrome(string s) {
    int left = 0, right = s.size() - 1;
    while (left < right) {
        if (s[left] != s[right]) return false;
        left++;
        right--;
    }
    return true;
}
```

## 注意点

- 双指针方法可以处理字符串长度为奇数或偶数的情况。
- 在处理更复杂的回文判断时（如包含非字母字符、大小写不敏感），可能需要在上述代码中添加额外的逻辑。

```

你可以复制上面的 Markdown 代码并将其粘贴到任何支持 Markdown 格式的编辑器中，它将正确地格式化内容。
